/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stdio.h>
#include"main.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void delay(void);

int main(void)
{
	RCC_AHB1ENR_t volatile *const pRCC_AHB1ENR   = (RCC_AHB1ENR_t *)(0x40023800+0x30);//this pointer is to point the content in RCC clk enable register for the port D
	GPIOx_MODER_u volatile *const pGPIOD_MODER   = (GPIOx_MODER_u *)(0x40020C00+0x00);//this pointer is to point the content of the GPIO MODER register
	GPIOx_PUPDR_u volatile *const pGPIOD_PUPDR	= (GPIOx_PUPDR_u*)(0x40020C00+0x0C);//this for enabling the pull up and pull down register for the port D
	GPIOx_ODR_u   volatile *const pGPIOD_ODR     = (GPIOx_ODR_u *)(0x40020C00+0x14);//this pointer is used to modify the content of the output register of the port D
	GPIOx_IDR_u   volatile *const pGPIOD_IDR 	= (GPIOx_IDR_u *)(0x40020C00+0x10);//this for accessing the content of port D input data register
	pRCC_AHB1ENR->GPIOD_EN    = 0b1;//enabling the clk to the port D
	pGPIOD_MODER->MODER_0_3   = 0x55;//making the portD pin 0 to 3 as output pin
	pGPIOD_MODER->MODER_8_11  = 0x00;//making the portD pin 8 to 11 as input pin
	pGPIOD_PUPDR->PUPDR_8_11    = 0x55;//enabling the pull up register of the port D pin 8 to 11

	pGPIOD_ODR->ODR_0_3     = 0xF;//setting the output pin 0 to 3 output data register value initially as one
	//no need to configure the pGPIO_IDR bcz pull up already set it value to one means no key pressed


	while(1){

		{//making the first row zero
			pGPIOD_ODR->ODR_0_3 = 0b1110;
			if(pGPIOD_IDR->IDR_8_11 == 0b1110){
				printf("\n1");
				fflush(stdout);
				delay();
			}
			else if(pGPIOD_IDR->IDR_8_11 == 0b1101){
				printf("\n2");
				fflush(stdout);
				delay();
			}

			else if(pGPIOD_IDR->IDR_8_11 == 0b1011){
				printf("\n3");
				fflush(stdout);
				delay();
			}

			else if(pGPIOD_IDR->IDR_8_11 == 0b0111){
				printf("\nA");
				fflush(stdout);
				delay();
			}
			else;

		}

		{//making the second row zero
			pGPIOD_ODR->ODR_0_3 = 0b1101;
			if(pGPIOD_IDR->IDR_8_11 == 0b1110){
				printf("\n4");
				fflush(stdout);
				delay();
			}
			else if(pGPIOD_IDR->IDR_8_11 == 0b1101){
				printf("\n5");
				fflush(stdout);
				delay();
			}

			else if(pGPIOD_IDR->IDR_8_11 == 0b1011){
				printf("\n6");
				fflush(stdout);
				delay();
			}

			else if(pGPIOD_IDR->IDR_8_11 == 0b0111){
				printf("\nB");
				fflush(stdout);
				delay();
			}
			else;

		}

		{//making the third row zero
			pGPIOD_ODR->ODR_0_3 = 0b1011;
			if(pGPIOD_IDR->IDR_8_11 == 0b1110){
				printf("\n7");
				fflush(stdout);
				delay();
			}
			else if(pGPIOD_IDR->IDR_8_11 == 0b1101){
				printf("\n8");
				fflush(stdout);
				delay();
			}

			else if(pGPIOD_IDR->IDR_8_11 == 0b1011){
				printf("\n9");
				fflush(stdout);
				delay();
			}

			else if(pGPIOD_IDR->IDR_8_11 == 0b0111){
				printf("\nC");
				fflush(stdout);
				delay();
			}
			else;

		}


		{//making the last row zero
			pGPIOD_ODR->ODR_0_3 = 0b0111;
			if(pGPIOD_IDR->IDR_8_11 == 0b1110){
				printf("\n*");
				fflush(stdout);
				delay();
			}
			else if(pGPIOD_IDR->IDR_8_11 == 0b1101){
				printf("\n0");
				fflush(stdout);
				delay();
			}

			else if(pGPIOD_IDR->IDR_8_11 == 0b1011){
				printf("\n#");
				fflush(stdout);
				delay();
			}

			else if(pGPIOD_IDR->IDR_8_11 == 0b0111){
				printf("\nD");
				fflush(stdout);
				delay();
			}
			else;

		}
	}


}


void delay(void)
{
    /* 300,000 ITERATIONS IS APPROXIMATELY 150MS AT 16MHZ */
    for( uint32_t volatile i = 0; i < 350000; i++);
}

